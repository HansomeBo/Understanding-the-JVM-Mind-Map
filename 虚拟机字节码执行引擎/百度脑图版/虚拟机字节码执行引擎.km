{"root":{"data":{"id":"94aff08afcfc","created":1564241753,"text":"虚拟机字节码执行引擎","expandState":"expand"},"children":[{"data":{"id":"bvu5frofmls0","created":1564241793869,"text":"执行形式","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvu5froff1c0","created":1564241793869,"text":"解释执行","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvu5frog0qo0","created":1564241793870,"text":"通过解释器执行","layout":null},"children":[]}]},{"data":{"id":"bvu5frogga80","created":1564241793870,"text":"编译执行","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvu5frog8880","created":1564241793870,"text":"通过即时编译期产生本地代码执行","layout":null},"children":[]}]},{"data":{"id":"bvu5frofz200","created":1564241793870,"text":"两者兼备","layout":null},"children":[]}]},{"data":{"id":"bvu5nctzdlc0","created":1564242388466,"text":"运行时栈帧","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvu5o90zk1s0","created":1564242458547,"text":" ","image":"http://kityminder-img.gz.bcebos.com/d26b1da15f62bec4095117e1e2ebc14007542c01","imageTitle":"","imageSize":{"width":189,"height":200},"layout":null},"children":[]}]},{"data":{"id":"bvu6aubvwaw0","created":1564244228930,"text":"方法调用","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvu6aubwm400","created":1564244228931,"text":"概述","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvu6aubwnm00","created":1564244228931,"text":"方法调用并不等于方法执行，方法调用阶段唯一的任务就是确定调用哪个方法，不涉及到方法内部的具体运行过程。","layout":null},"children":[]}]},{"data":{"id":"bvu6aubx6qo0","created":1564244228932,"text":"解析调用（Resolution）","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvu6dv2u3so0","created":1564244465652,"text":"Class中只有符号引用，因此要在类加载期间，甚至到运行期才能确定目标方法的直接引用","layout":null},"children":[]},{"data":{"id":"bvu6flmxxeo0","created":1564244601828,"text":"因此，如果调用目标能在代码写好、编译器编译就确定下来，那么这种方法的调用称为解析","layout":null},"children":[]},{"data":{"id":"bvu6aubxsi00","created":1564244228933,"text":"满足这种条件的叫非虚方法","expandState":"expand","layout":null},"children":[{"data":{"id":"bvu6auby5pk0","created":1564244228934,"text":"调用静态方法","layout":null},"children":[]},{"data":{"id":"bvu6aubyca80","created":1564244228934,"text":"调用实例构造器<init>方法","layout":null},"children":[]},{"data":{"id":"bvu6noe68ww0","created":1564245234741,"text":"私有方法","layout":null},"children":[]},{"data":{"id":"bvu6nqb1m680","created":1564245238906,"text":"父类方法","layout":null},"children":[]},{"data":{"id":"bvu6otpad340","created":1564245324662,"text":"final方法也是","layout":null},"children":[]}]}]},{"data":{"id":"bvupxoq51p40","created":1564299620195,"text":"分派调用","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvupxtx7ziw0","created":1564299631507,"text":"静态分派","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvur1n2aeao0","created":1564302751142,"text":"重载（Overload）","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvur1pf536w0","created":1564302756273,"text":"重载时是通过参数的静态类型而不是实际类型作为判断依据的","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvur27xmaso0","created":1564302796573,"text":" ","note":"package com.jvm;\n\n/**\n * 方法静态分派演示\n * @author zzm\n */\n public class StaticDispatch {\n\n    static abstract class Human {\n    }\n\n    static class Man extends Human {\n    }\n\n    static class Woman extends Human {\n    }\n\n    public void sayHello(Human guy) {\n        System.out.println(\"hello,guy!\");\n    }\n\n    public void sayHello(Man guy) {\n        System.out.println(\"hello,gentleman!\");\n    }\n\n    public void sayHello(Woman guy) {\n        System.out.println(\"hello,lady!\");\n    }\n\n    public static void main(String[] args) {\n        Human man = new Man();\n        Human woman = new Woman();\n        StaticDispatch sr = new StaticDispatch();\n        sr.sayHello(man);\n        sr.sayHello(woman);\n    }\n}\n\n// 实际类型变化\nHuman man = new Man();\nman = new Woman();\n// 静态类型变化\nsr.sayHello((Man)man);\nsr.sayHello((Woman)man);\n\n","layout":null},"children":[]}]},{"data":{"id":"bvura58x2ko0","created":1564303417639,"text":"有时候重载情况不唯一","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvuradvv2eg0","created":1564303436440,"text":"因为字面量不需要定义，没有显式的静态类型","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvurare4sps0","created":1564303465843,"text":" ","note":"package com.jvm;\n\nimport java.io.Serializable;\n\n/**\n * @author 肥宅快乐码\n * @date 2019/7/28 - 16:47\n */\npublic class Overload {\n\n    public static void sayHello(Object arg) {\n        System.out.println(\"hello Object\");\n    }\n\n    public static void sayHello(int arg) {\n        System.out.println(\"hello int\");\n    }\n\n    public static void sayHello(long arg) {\n        System.out.println(\"hello long\");\n    }\n\n    public static void sayHello(Character arg) {\n        System.out.println(\"hello Character\");\n    }\n\n    public static void sayHello(char arg) {\n        System.out.println(\"hello char\");\n    }\n\n    public static void sayHello(char... arg) {\n        System.out.println(\"hello char ...\");\n    }\n\n    public static void sayHello(Serializable arg) {\n        System.out.println(\"hello Serializable\");\n    }\n\n    public static void main(String[] args) {\n        sayHello('a');\n    }\n}\n\n","layout":null},"children":[]},{"data":{"id":"bvure20neds0","created":1564303724065,"text":"只能选择更为合适的方法进行重载","layout":null},"children":[]},{"data":{"id":"bvureddzxx40","created":1564303748817,"text":"例如'a'可以为char，也可以为整数97","layout":null},"children":[]},{"data":{"id":"bvureqlo3sg0","created":1564303777579,"text":"这种叫向上转型","layout":null},"children":[]},{"data":{"id":"bvurh4p3qaw0","created":1564303964990,"text":"其中Character实现了Serializable接口，在char、int、long、Character后会转成他，然后就是Object了，最后就是变长参数char...,当然char...不能转int...","layout":null},"children":[]}]}]}]}]},{"data":{"id":"bvupyrrt30o0","created":1564299705190,"text":"动态分派","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvuriwyzr740","created":1564304104902,"text":"重写（Override）","expandState":"collapse","layout":null},"children":[{"data":{"id":"bvurjcgofk80","created":1564304138623,"text":" ","note":"package com.jvm;\n\n/**\n * 方法动态分派演示\n * @author zzm\n */\npublic class DynamicDispatch {\n\n    static abstract class Human {\n        protected abstract void sayHello();\n    }\n\n    static class Man extends Human {\n        @Override\n        protected void sayHello() {\n            System.out.println(\"man say hello\");\n        }\n    }\n\n    static class Woman extends Human {\n        @Override\n        protected void sayHello() {\n            System.out.println(\"woman say hello\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Human man = new Man();\n        Human woman = new Woman();\n        man.sayHello();\n        woman.sayHello();\n        man = new Woman();\n        man.sayHello();\n    }\n}\n\n// man say hello\n// woman say hello\n// woman say hello\n\n","layout":null},"children":[]}]}]},{"data":{"id":"bvusjiqw8jk0","created":1564306973411,"text":"单分派和多分派","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvusk76lp3c0","created":1564307026604,"text":"方法的接收者与方法的参数统称为方法的宗量","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvusne5nrrs0","created":1564307276877,"text":"多于一个宗量对目标方法选择","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvusnmjljsw0","created":1564307295134,"text":"多分派","layout":null},"children":[{"data":{"id":"bvuss2mxpc00","created":1564307643621,"text":"静态分派","layout":null},"children":[{"data":{"id":"bvuss9nvnvk0","created":1564307658915,"text":"宗量一、静态类型（方法调用者）是Father还是Son，都是Father","layout":null},"children":[]},{"data":{"id":"bvussxmf1cw0","created":1564307711070,"text":"宗量二、方法参数是QQ还是360","layout":null},"children":[]},{"data":{"id":"bvustcwkumw0","created":1564307744336,"text":"Father.hardChoice(360)","layout":null},"children":[]},{"data":{"id":"bvustls4i200","created":1564307763658,"text":"Father.hardChoice(QQ)","layout":null},"children":[]}]}]}]},{"data":{"id":"bvuskubqpeo0","created":1564307076981,"text":"根据一个宗量对目标方法选择","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bvusnahwmtk0","created":1564307268910,"text":"单分派","layout":null},"children":[{"data":{"id":"bvustu57yww0","created":1564307781864,"text":"动态分派","layout":null},"children":[{"data":{"id":"bvustzhnbaw0","created":1564307793499,"text":"宗量一、实际类型（方法调用者）决定目标方法","layout":null},"children":[]}]}]}]},{"data":{"id":"bvusqqp8gg00","created":1564307539274,"text":" ","note":"package com.jvm;\n\n/**\n * 单分派、多分派演示\n * @author zzm\n */\npublic class Dispatch {\n\n    static class QQ {}\n\n    static class _360 {}\n\n    public static class Father {\n        public void hardChoice(QQ arg) {\n            System.out.println(\"father choose qq\");\n        }\n\n        public void hardChoice(_360 arg) {\n            System.out.println(\"father choose 360\");\n        }\n    }\n\n    public static class Son extends Father {\n        @Override\n        public void hardChoice(QQ arg) {\n            System.out.println(\"son choose qq\");\n        }\n\n        @Override\n        public void hardChoice(_360 arg) {\n            System.out.println(\"son choose 360\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Father father = new Father();\n        Father son = new Son();\n        father.hardChoice(new _360());\n        son.hardChoice(new QQ());\n    }\n}\n\n\n","layout":null},"children":[]}]}]}]}]},{"data":{"id":"bvut3e66dfs0","created":1564308530735,"text":"基于栈的字节码解释执行引擎"},"children":[]}]},"template":"right","theme":"classic-compact","version":"1.4.43"}